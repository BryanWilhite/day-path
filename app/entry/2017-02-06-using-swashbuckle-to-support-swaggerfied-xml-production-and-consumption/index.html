<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="ie=edge" />
        <meta name="description" content="my technical Blog ✒ for my studio" />
        <meta name="robots" content="index, follow" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <meta name="google-site-verification" content="MyXJp0qYgoTSi472GCarwPFWqvRZAo8khVV_FXV33tI" />
        <meta name="msvalidate.01" content="9C08B066B4967EBE515E0CC7C146DE30" />

        <base href="http://songhayblog.azurewebsites.net/" />

        <link rel="canonical" href="http://songhayblog.azurewebsites.net/" />
        <link rel="alternate" type="application/atom+xml" title="day path" href="/entry/feed.xml" />
        <link rel="SHORTCUT ICON" href="http://songhayblog.azurewebsites.net/image/favicon.ico" />
        <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
        <link href="http://songhayblog.azurewebsites.net/style/styles.min.css" rel="stylesheet" />

        <script src="http://songhayblog.azurewebsites.net/script/index.min.js"></script>

        <title>Using Swashbuckle to Support Swaggerfied XML Production and Consumption - day path</title>
    </head>

    <body class="mdc-typography">
        <header class="mdc-top-app-bar mdc-top-app-bar--short">
            <div class="mdc-top-app-bar__row">
                <section class="mdc-top-app-bar__section mdc-top-app-bar__section--align-start">
                    <a href="http://songhayblog.azurewebsites.net/" class="material-icons mdc-top-app-bar__navigation-icon">first_page</a>
                    <span class="mdc-top-app-bar__title">day path</span>
                </section>
                <section class="description mdc-top-app-bar__section mdc-top-app-bar__section--align-end">
                    my technical Blog ✒ for my studio
                </section>
            </div>
        </header>
        <main class="mdc-layout-grid" id="main-content">
            <section class="entry">

    <h1>Using Swashbuckle to Support Swaggerfied XML Production and Consumption</h1>
<p>Every ASP.NET NuGet package that I have used before <a href="http://www.nuget.org/packages/Swashbuckle/5.5.3">Swashbuckle</a> spoiled me with just working out of the box and/or having decent documentation. When I used <a href="https://www.nuget.org/packages/elmah/">ELMAH</a> (before <a href="https://azure.microsoft.com/en-us/services/application-insights/">Application Insights</a>), I <em>felt</em> that it just worked. <a href="https://www.nuget.org/packages/Autofac/">Autofac</a> gives me that same feeling as well (in spite of some <a href="http://songhayblog.azurewebsites.net/entry/my-autofac-packages-drama">drama</a>). My point is that Swashbuckle really stands out due to my particular approach to the technology.</p>
<p>My approach (due to the demands of my day job) is the need to consume/produce XML. I am deliberately using consume/produce, by the way, to align with produces/consumes of <a href="http://swagger.io/specification/">the Swagger Specification</a>. So let’s take a look at the default Swagger UI for an XML endpoint auto-generated by version 5.5.3 of Swashbuckle:</p>
<div style="text-align:center">
<p><a href="https://www.flickr.com/photos/wilhite/31941217903/in/dateposted-public/"><img src="https://farm1.staticflickr.com/645/31941217903_4d0bf088c2_z_d.jpg" alt="Swashbuckle Swagger UI is JSON-centric by default" title="!*m81"></a></p>
</div>
<p>It took me awhile to notice the obvious: Swashbuckle is biased toward JSON. This makes perfect sense until we go back to XML. Here is the ASP.NET Web API controller method that Swashbuckle is working with:</p>
<pre><code class="language-c#">/// &lt;summary&gt;
/// Consumes the XML.
/// &lt;/summary&gt;
/// &lt;param name=&quot;xmlInput&quot;&gt;The XML input.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
/// &lt;remarks&gt;
/// This endpoint cannot catch malformed XML errors for the logging system.
/// This endpoint was intended for use in Swagger,
/// using the same critical code that the production endpoint uses.
/// &lt;/remarks&gt;
[HttpPost]
[Route(&quot;xml-endpoint&quot;)]
public IHttpActionResult ConsumeXml([FromBody]XElement xmlInput)
{
    return this.Ok&lt;XElement&gt;(xmlInput.ToResponseDocument());
}
</code></pre>
<p>When I mention that <code>ToResponseDocument()</code> in the method body above is just an some custom extension method that I wrote, we can disregard the method body. Swashbuckle is pretty much doing that as well. In order to get Swashbuckle to tell Swagger to consume/produce XML <em>exclusively</em>, we need to add my custom method attribute, <code>SwaggerContentType</code>, and my class implementing <code>IOperationFilter</code> (<a href="https://github.com/domaindrivendev/Swashbuckle/blob/master/Swashbuckle.Core/Swagger/IOperationFilter.cs">in Swashbuckle.Core</a>), <code>SwaggerContentTypeOperationFilter</code>, mediated by entries in <code>SwaggerConfig.cs</code>.</p>
<p>We can see what our controller method looks like with <code>SwaggerContentType</code> declaring Swagger production and consumption:</p>
<pre><code class="language-c#">/// &lt;summary&gt;
/// Consumes the XML.
/// &lt;/summary&gt;
/// &lt;param name=&quot;xmlInput&quot;&gt;The XML input.&lt;/param&gt;
/// &lt;returns&gt;&lt;/returns&gt;
/// &lt;remarks&gt;
/// This endpoint cannot catch malformed XML errors for the logging system.
/// This endpoint was intended for use in Swagger,
/// using the same critical code that the production endpoint uses.
/// &lt;/remarks&gt;
[HttpPost]
[Route(&quot;xml-endpoint&quot;)]
[SwaggerContentType(mimeType: MimeTypes.ApplicationXml,
    IsExclusive = true,
    IsConsumption = false,
    Tag = nameof(MyController.ConsumeXml))]
[SwaggerContentType(mimeType: MimeTypes.ApplicationXml,
    IsExclusive = true,
    IsConsumption = true,
    MethodParameterName = &quot;xmlInput&quot;,
    Tag = nameof(MyController.ConsumeXml))]
public IHttpActionResult ConsumeXml([FromBody]XElement xmlInput)
{
    return this.Ok&lt;XElement&gt;(xmlInput.ToResponseDocument());
}
</code></pre>
<p>With these attributes (and their backing <code>IOperationFilter</code> classes), we can now see Swashbuckle generating improved Swagger:</p>
<div style="text-align:center">
<p><a href="https://www.flickr.com/photos/wilhite/32714653736/in/dateposted-public/"><img src="https://farm1.staticflickr.com/584/32714653736_330d5a60cd_z_d.jpg" alt="Swashbuckle Swagger UI with basic XML customization"></a></p>
</div>
<p>To make this happen, <code>SwaggerContentTypeOperationFilter</code> pulls our custom attributes by LINQ-querying <a href="https://msdn.microsoft.com/en-us/library/system.web.http.description.apidescription%28v=vs.118%29.aspx"><code>ApiDescription</code></a>. We can use this custom attribute data to edit an instance of Swashbuckle’s <code>Operation</code> class (which is on line 99 of <code>SwaggerDocument.cs</code> class <a href="https://github.com/domaindrivendev/Swashbuckle/blob/master/Swashbuckle.Core/Swagger/SwaggerDocument.cs#L99">in the current master</a>). My GitHub <a href="https://gist.github.com/BryanWilhite/1a0e8c14a5002995aa5eb7984bfa5cd0#file-swaggercontenttypeoperationfilter-cs">Gist shows</a><code>SwaggerContentTypeOperationFilter</code><em>applying</em> these changes, handling Swagger consumption <em>and</em> production.</p>
<p>Once all of these classes are in place and the method attributes are adorning, we can add this mediating line to that <code>GlobalConfiguration.Configuration.EnableSwagger</code> lambda expression in <code>SwaggerConfig.cs</code> jam-packed with comments:</p>
<pre><code class="language-c#">// Similar to Schema filters, Swashbuckle also supports Operation and Document filters:
//
// Post-modify Operation descriptions once they've been generated by wiring up one or more
// Operation filters.
//
//c.OperationFilter&lt;AddDefaultResponse&gt;();
//
// Set filter to apply Custom Content Types to operations
c.OperationFilter&lt;SwaggerContentTypeOperationFilter&gt;();
</code></pre>
<p>I notice that all of this work has no control over the “Example Value” XML shown in the Swagger UI. I think this is controlled by <a href="http://swagger.io/specification/#definitionsObject">the Swagger Definitions Object</a>. Assuming that a newer version of Swashbuckle will <em>not</em> get this working out of the box <em>for XML</em>, I will have to come back to this later.</p>
<p>@<a href="https://twitter.com/BryanWilhite">BryanWilhite</a></p>


</section>
<section class="meta">
    <span class="entry-date"> <strong>incept date:</strong> EEEE, MMMM d, y </span>
</section>
        </main>
        <footer>
            <div class="col-sm-8">
                <p>
                    Last Reviewed:
                    2017-02-07T02:33:53.712Z
                </p>
                <p>
                    Another stone tribal move by <a class="welcome" href="http://songhaysystem.com/">Songhay System</a>
                </p>
            </div>
            <div class="col-sm-4">
                <a href="http://twitter.com/BryanWilhite" target="_blank" title="@BryanWilhite">
                    <span class="zocial twitter icon"></span>
                </a>
                <a href="http://songhayblog.azurewebsites.net/entry/feed.xml" target="_blank" title="Atom feed">
                    <span class="zocial rss icon"></span>
                </a>
            </div>
        </footer>
    </body>

</html>