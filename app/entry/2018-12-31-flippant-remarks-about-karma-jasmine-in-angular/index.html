<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="ie=edge" />
        <meta name="description" content="my technical Blog ✒ for my studio" />
        <meta name="robots" content="index, follow" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <meta name="google-site-verification" content="MyXJp0qYgoTSi472GCarwPFWqvRZAo8khVV_FXV33tI" />
        <meta name="msvalidate.01" content="9C08B066B4967EBE515E0CC7C146DE30" />

        <base href="http://songhayblog.azurewebsites.net/" />

        <link rel="canonical" href="http://songhayblog.azurewebsites.net/" />
        <link rel="alternate" type="application/atom+xml" title="day path" href="/entry/feed.xml" />
        <link rel="SHORTCUT ICON" href="http://songhayblog.azurewebsites.net/image/favicon.ico" />
        <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
        <link href="http://songhayblog.azurewebsites.net/style/styles.min.css" rel="stylesheet" />

        <script src="http://songhayblog.azurewebsites.net/script/index.min.js"></script>

        <title>flippant remarks about Karma-Jasmine in Angular - day path</title>
    </head>

    <body class="mdc-typography">
        <header class="mdc-top-app-bar mdc-top-app-bar--short">
            <div class="mdc-top-app-bar__row">
                <section class="mdc-top-app-bar__section mdc-top-app-bar__section--align-start">
                    <a href="http://songhayblog.azurewebsites.net/" class="material-icons mdc-top-app-bar__navigation-icon">first_page</a>
                    <span class="mdc-top-app-bar__title">day path</span>
                </section>
                <section class="description mdc-top-app-bar__section mdc-top-app-bar__section--align-end">
                    my technical Blog ✒ for my studio
                </section>
            </div>
        </header>
        <main class="mdc-layout-grid" id="main-content">
            <section class="entry">

    <h1>flippant remarks about Karma-Jasmine in Angular</h1>
<p>The details below try to explain these fundamentals:</p>
<ul>
<li>use <code>NO_ERRORS_SCHEMA</code></li>
<li>initialize properties used in component-binding HTML to prevent <code>[object ErrorEvent] thrown</code></li>
<li>call <code>overrideComponent</code> to null or mock services for the component spec</li>
<li>consider using inline mocks with <code>useValue</code> for providers</li>
<li>consider using the “Elvis operator” in component-binding HTML</li>
<li>be ready to use <code>HttpClientTestingModule</code>, <code>HttpTestingController</code> and/or <code>RouterTestingModule</code></li>
<li>comment out <code>fixture.detectChanges()</code> to narrow down troubleshooting binding or initialization issues</li>
</ul>
<p>One, <a href="https://github.com/BryanWilhite/nodejs/tree/master/karma-and-jasmine-minimal">small introduction to Karma-Jasmine</a> outside of Angular reminds us <a href="https://karma-runner.github.io/latest/index.html">Karma</a> is the “test runner” (from the Angular team) and <a href="https://jasmine.github.io/">Jasmine</a> is a behavior driven development framework. <a href="https://en.wikipedia.org/wiki/Behavior-driven_development">Behavior Driven Development</a> is beyond the scope of these remarks apart from the consideration that we might make when use the word <em>specification</em> instead of <em>test</em>.</p>
<h2>a Jasmine <code>*.spec.ts</code> file is generated by the Angular CLI by default</h2>
<p>Unless the <code>--spec=false</code> option is explicitly used, <code>ng generate component</code> [<a href="https://angular.io/cli/generate#component">docs</a>] will auto-generate a Jasmine spec file like this:</p>
<pre><code class="language-typescript">import { async, ComponentFixture, TestBed } from '@angular/core/testing';

import { MyComponent } from './my.component';

describe('MyComponent', () =&gt; {
    let component: MyComponent;
    let fixture: ComponentFixture&lt;MyComponent&gt;;

beforeEach(async(() =&gt; {
    TestBed.configureTestingModule({
        declarations: [ MyComponent ]
    })
    .compileComponents();
    }));

beforeEach(() =&gt; {
    fixture = TestBed.createComponent(MyComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
    });

it('should create', () =&gt; {
    expect(component).toBeTruthy();
    });
});
</code></pre>
<p>One way to easily be confused by the Karma-Jasmine combo is not really, really understanding that <code>async</code>, <code>ComponentFixture</code> and <code>TestBed</code> do <em>not</em> come from Jasmine—we must depend on the Angular team to <a href="https://angular.io/guide/testing">tell us</a> about these things. One of these things is the use of <code>async</code> with <code>beforeEach</code>. A <a href="https://stackoverflow.com/a/40127164/22944">StackOverflow.com answer</a> asserts that <code>async</code> (from the Angular team) replaces the use of <code>done()</code> which is native to Jasmine [<a href="https://jasmine.github.io/tutorials/async">docs</a>]. <code>ComponentFixture</code> and <code>TestBed</code> are covered reasonably well by the Angular team [<a href="https://angular.io/guide/testing#component-test-basics">docs</a>].</p>
<h2>using <code>NO_ERRORS_SCHEMA</code></h2>
<p>The auto-generated test above might be for a component with an HTML file like this:</p>
<pre><code class="language-html">&lt;span class=&quot;kw&quot;&gt;&lt;div&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; class=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;css-class&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&gt;&lt;/span&gt;]()&lt;span class=&quot;kw&quot;&gt;&lt;app-my-child&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; [prop1]=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;foo.bar&quot;&lt;/span&gt;&lt;span class=&quot;ot&quot;&gt; [prop2]=&lt;/span&gt;&lt;span class=&quot;st&quot;&gt;&quot;fuBar.prop3&quot;&lt;/span&gt;&lt;span class=&quot;kw&quot;&gt;&gt;&lt;/app-my-child&gt;&lt;/span&gt;]()[&lt;span class=&quot;kw&quot;&gt;&lt;/div&gt;&lt;/span&gt;]()&lt;/code&gt;

&lt;/div&gt;
</code></pre>
<p>By default, the test will likely throw a very verbose error like this:</p>
<pre><code class="language-console">Failed: Template parse errors:
        'app-my-child' is not a known element:
        1. If 'app-my-child' is an Angular component, then verify that it is part of this module.
        …
</code></pre>
<p>We need to tell our <code>TestBed</code> to ignore “custom” elements like <code>app-my-child</code>:</p>
<pre><code class="language-typescript">import { NO_ERRORS_SCHEMA } from '@angular/core';

import { async, ComponentFixture, TestBed } from '@angular/core/testing';

import { MyComponent } from './my.component';

describe(MyComponent.name, () =&gt; {
    let component: MyComponent;
    let fixture: ComponentFixture&lt;MyComponent&gt;;

beforeEach(async(() =&gt; {
    TestBed.configureTestingModule({
        declarations: [ MyComponent ],
        schemas: [ NO_ERRORS_SCHEMA ]
    })
    .compileComponents();
    }));

beforeEach(() =&gt; {
    fixture = TestBed.createComponent(MyComponent);
    component = fixture.componentInstance;
    fixture.detectChanges();
    });

it('should create', () =&gt; {
    expect(component).toBeTruthy();
    });
});
</code></pre>
<p>For more detail on <code>NO_ERRORS_SCHEMA</code>, see the <a href="https://angular.io/guide/testing#no_errors_schema">docs</a>. Also note that we can cut down on the use of magic strings by using <code>MyComponent.name</code> which is convenience from the Angular team.</p>
<h2>the mysterious <code>[object ErrorEvent] thrown</code> error</h2>
<p>The <code>NO_ERRORS_SCHEMA</code> remedy might be followed by another, more mysterious Jasmine error:</p>
<p><code>[object ErrorEvent] thrown</code></p>
<p>What is happening in our HTML example above is the null value of <code>foo</code> in the binding <code>foo.bar</code> and the null value of <code>fuBar</code> in the binding <code>fuBar.prop3</code>. The typescript of a component backing these bindings might look like this:</p>
<pre><code class="language-typescript">import { Component, OnInit } from '@angular/core';
import { FooService } from '../../services/foo.service';

@Component({
    selector: 'app-my-widget',
    templateUrl: './my.component.html',
    styleUrls: ['./my.component.css']
})
export class ContextPanelComponent implements OnInit {
    @Input
    fuBar: {};

constructor(public foo: FooService) { }

ngOnInit() {
    foo.loadBar();
    }
}
</code></pre>
<p>We see that <code>fuBar</code> is an <code>@Input</code> property and <code>foo</code> is injected as a service. To address these members of the component, we update our Jasmine spec:</p>
<pre><code class="language-typescript">import { NO_ERRORS_SCHEMA } from '@angular/core';

import { async, ComponentFixture, TestBed } from '@angular/core/testing';

import { FooService } from '../../services/foo.service';
import { MyComponent } from './my.component';

describe(MyComponent.name, () =&gt; {
    let component: MyComponent;
    let fixture: ComponentFixture&lt;MyComponent&gt;;

    beforeEach(async(() =&gt; {
        TestBed.configureTestingModule({
            declarations: [ MyComponent ],
            schemas: [ NO_ERRORS_SCHEMA ]
        })
        .overrideComponent(MyComponent, {
            set: { providers: [ { provide: FooService, useValue: null } ] }
        })
        .compileComponents();
    }));

    beforeEach(() =&gt; {
        fixture = TestBed.createComponent(MyComponent);
        component = fixture.componentInstance;

        component.fuBar = { prop3: null };

        fixture.detectChanges();
    });

    it('should create', () =&gt; {
        expect(component).toBeTruthy();
    });
});
</code></pre>
<p>This updated spec should still throw the same cryptic error, <code>[object ErrorEvent] thrown</code>, because, while we <em>did</em> address <code>fuBar</code>, we did <em>not</em> provide a value for <code>FooService</code>. It is often useful to provide a null value for a service to show that the service might not be necessary and should be removed from the component. Let’s flippantly provide a value for <code>FooService</code>:</p>
<pre><code class="language-typescript">import { NO_ERRORS_SCHEMA } from '@angular/core';

import { async, ComponentFixture, TestBed } from '@angular/core/testing';

import { FooService } from '../../services/foo.service';
import { MyComponent } from './my.component';

describe(MyComponent.name, () =&gt; {
    const fooService = { bar: null };

    let component: MyComponent;
        let fixture: ComponentFixture&lt;MyComponent&gt;;

    beforeEach(async(() =&gt; {
        TestBed.configureTestingModule({
            declarations: [ MyComponent ],
            schemas: [ NO_ERRORS_SCHEMA ]
        })
        .overrideComponent(MyComponent, {
            set: { providers: [ { provide: FooService, useValue: fooService } ] }
        })
        .compileComponents();
    }));

    beforeEach(() =&gt; {
        fixture = TestBed.createComponent(MyComponent);
        component = fixture.componentInstance;

        component.fuBar = { prop3: null };

        fixture.detectChanges();
    });

    it('should create', () =&gt; {
        expect(component).toBeTruthy();
    });
});
</code></pre>
<p>The spec should now be valid. Now we can actually specify an interesting behavior (write an actual test). Let’s test whether <code>foo.loadBar()</code> was called by <em>spying</em> on it. We can replace <code>fooService</code> with the value of <code>createSpyObj()</code> [<a href="https://jasmine.github.io/api/2.8/jasmine.html#.createSpyObj">docs</a>]:</p>
<pre><code class="language-typescript">import { NO_ERRORS_SCHEMA } from '@angular/core';

import { async, ComponentFixture, TestBed } from '@angular/core/testing';

import { FooService } from '../../services/foo.service';
import { MyComponent } from './my.component';

describe(MyComponent.name, () =&gt; {
    const loadBarMethodName = 'loadBar';
    const fooService = jasmine.createSpyObj(FooService.Name, [loadBarMethodName]);
    fooService.bar = null;

    let component: MyComponent;
        let fixture: ComponentFixture&lt;MyComponent&gt;;

    beforeEach(async(() =&gt; {
        TestBed.configureTestingModule({
            declarations: [ MyComponent ],
            schemas: [ NO_ERRORS_SCHEMA ]
        })
        .overrideComponent(MyComponent, {
            set: { providers: [ { provide: FooService, useValue: fooService } ] }
        })
        .compileComponents();
    }));

    beforeEach(() =&gt; {
        fixture = TestBed.createComponent(MyComponent);
        component = fixture.componentInstance;

        fooService[loadBarMethodName].calls.reset();
        component.fuBar = { prop3: null };

        fixture.detectChanges();
    });

    it('should create', () =&gt; {
        expect(component).toBeTruthy();
    });

    it(`should call ${loadBarMethodName}`, () =&gt; {
        expect(fooService[loadBarMethodName].calls.count()).toBe(1, 'The expected number of service calls is not here.');
    });

});
</code></pre>
<p>In typescript, <code>fooService</code> will be of type <code>any</code>. So, when we see the <code>calls</code> object (or “namespace”) hanging off it, we might need to go to <a href="https://jasmine.github.io/api/2.8/Spy_calls.html">the Jasmine documentation</a> to see what is going on.</p>
<h2>use of the “Elvis operator” in component-binding HTML</h2>
<p>Had our HTML been like this:</p>
<pre><code class="language-html">&lt;div class=&quot;css-class&quot;&gt;&lt;app-my-child prop1]=&quot;foo?.bar&quot; prop2=&quot;fuBar?.prop3&quot;&gt;&lt;/app-my-child&gt;&lt;/div&gt;
</code></pre>
<p>We could have avoided writing these lines of spec code:</p>
<pre><code class="language-typescript">fooService.bar = null;
…
component.fuBar = { prop3: null };
</code></pre>
<p>The use the Elvis operator has some issues with async in bindings, see “<a href="https://hackernoon.com/the-angry-angular-asyncpipe-the-evil-elvis-operator-89293e37e04d">The Angry Angular AsyncPipe &amp; The Evil Elvis Operator</a>” by Vitaliy Isikov.</p>
<h2>the ‘right’ way to initialize <code>@Input</code> values</h2>
<p>In my example above, you see me explicitly setting the value of <code>fuBar</code>. To test whether <code>@Input</code> is working (which is kind of like testing something that belongs to the Angular team) we can set up a mock component to host <code>MyComponent</code>. This is detailed in “<a href="https://medium.com/@AikoPath/testing-angular-components-with-input-3bd6c07cfaf6">Testing Angular components with @Input()</a>” by Aiko Klostermann of Thoughtworks.</p>
<h2>using formal mocks</h2>
<p>I am very, very certain that Angular team does not recommend constructing a mock inline as we have seen above:</p>
<pre><code class="language-typescript">const loadBarMethodName = 'loadBar';
const fooService = jasmine.createSpyObj(FooService.Name, [loadBarMethodName]);
fooService.bar = null;
</code></pre>
<p>I find this helpful when I am <em>not</em> repeating myself in multiple <code>*.spec.ts</code> files and it is less intimidating to first-time Jasmine writers.</p>
<h2>commenting out <code>fixture.detectChanges()</code></h2>
<p>Commenting out <code>fixture.detectChanges()</code> in specs might prevent the spec from throwing errors. This is a surefire way to consider that any failures with this line enabled are due to binding issues.</p>
<h2>the auto-generated tests for services look different</h2>
<p>When a test for a service is generated (with <code>ng generate service</code> [<a href="https://angular.io/cli/generate#service">docs</a>]) the main difference is the use of <code>inject</code> (also from the Angular team):</p>
<pre><code class="language-typescript">it('should be created', inject([MyService], (service: MyService) =&gt; {
    expect(service).toBeTruthy();
}));
</code></pre>
<p>The other difference is that you cannot use <code>overrideComponent</code> for a service spec; set <code>providers</code> in <code>configureTestingModule</code>:</p>
<pre><code class="language-typescript">beforeEach(async(() =&gt; {
    TestBed.configureTestingModule({
        imports: [HttpClientTestingModule, RouterTestingModule],
        providers: [ { provide: FooService, useValue: null } ]
    });
}));
</code></pre>
<h2>the <code>NullInjectorError: No provider for HttpClient!</code> error</h2>
<p>When the <code>NullInjectorError: No provider for HttpClient!</code> error is thrown, the knee-jerk response is to add <code>imports: [HttpClientModule]</code> to the <code>TestBed</code>. The better response is to import <code>HttpClientTestingModule</code> (with <code>HttpTestingController</code>) instead. This is detailed in “<a href="https://medium.com/netscape/testing-with-the-angular-httpclient-api-648203820712">Testing with the Angular HttpClient API</a>” by Ciro Nunes.</p>
<p>There is a similar Karma-Jasmine error that should lead us to importing <code>RouterTestingModule</code> as described in “<a href="https://medium.com/burak-tasci/using-jasmine-framework-to-test-angular-router-b568a232efed">Using Jasmine framework to test Angular Router</a>” by Burak Tasci.</p>
<p>@<a href="https://twitter.com/BryanWilhite">BryanWilhite</a></p>


</section>
<section class="meta">
    <span class="entry-date"> <strong>incept date:</strong> EEEE, MMMM d, y </span>
</section>
        </main>
        <footer>
            <div class="col-sm-8">
                <p>
                    Last Reviewed:
                    2018-12-31T19:42:59.177Z
                </p>
                <p>
                    Another stone tribal move by <a class="welcome" href="http://songhaysystem.com/">Songhay System</a>
                </p>
            </div>
            <div class="col-sm-4">
                <a href="http://twitter.com/BryanWilhite" target="_blank" title="@BryanWilhite">
                    <span class="zocial twitter icon"></span>
                </a>
                <a href="http://songhayblog.azurewebsites.net/entry/feed.xml" target="_blank" title="Atom feed">
                    <span class="zocial rss icon"></span>
                </a>
            </div>
        </footer>
    </body>

</html>