<!DOCTYPE html>
<html lang="en">

    <head>
        <meta charset="UTF-8" />
        <meta http-equiv="X-UA-Compatible" content="ie=edge" />
        <meta name="description" content="my technical Blog ✒ for my studio" />
        <meta name="robots" content="index, follow" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />

        <meta name="google-site-verification" content="MyXJp0qYgoTSi472GCarwPFWqvRZAo8khVV_FXV33tI" />
        <meta name="msvalidate.01" content="9C08B066B4967EBE515E0CC7C146DE30" />

        <base href="http://songhayblog.azurewebsites.net/" />

        <link rel="canonical" href="http://songhayblog.azurewebsites.net/" />
        <link rel="alternate" type="application/atom+xml" title="day path" href="/entry/feed.xml" />
        <link rel="SHORTCUT ICON" href="http://songhayblog.azurewebsites.net/image/favicon.ico" />
        <link rel="stylesheet" href="https://fonts.googleapis.com/icon?family=Material+Icons" />
        <link href="http://songhayblog.azurewebsites.net/style/styles.min.css" rel="stylesheet" />

        <script src="http://songhayblog.azurewebsites.net/script/index.min.js"></script>

        <title>Entity Framework and JSON.NET - day path</title>
    </head>

    <body class="mdc-typography">
        <header class="mdc-top-app-bar mdc-top-app-bar--short">
            <div class="mdc-top-app-bar__row">
                <section class="mdc-top-app-bar__section mdc-top-app-bar__section--align-start">
                    <a href="http://songhayblog.azurewebsites.net/" class="material-icons mdc-top-app-bar__navigation-icon">first_page</a>
                    <span class="mdc-top-app-bar__title">day path</span>
                </section>
                <section class="description mdc-top-app-bar__section mdc-top-app-bar__section--align-end">
                    my technical Blog ✒ for my studio
                </section>
            </div>
        </header>
        <main class="mdc-layout-grid" id="main-content">
            <section class="entry">

    <h1>Entity Framework and JSON.NET</h1>
<p>Converting code-first, EF6 Entity models to JSON (with JSON.NET) is more complicated than I expected. First of all, <code>Include()</code> does not behave as I expected (after one level as suggested in “<a href="https://entityframework.codeplex.com/workitem/2256">EF 6</a>” or “.<a href="https://entityframework.codeplex.com/discussions/436875">include with multiple levels</a>”).</p>
<p>For me, there was no difference between this:</p>
<pre><code class="language-c#">var segments = GetContext().Segments
        .Include(i =&gt; i.ChildSegments)
        .Where(i =&gt; (i.ParentSegmentId == null) &amp;&amp; i.IsActive.HasValue &amp;&amp; i.IsActive.Value)
        .OrderBy(i =&gt; i.SegmentName);
</code></pre>
<p>…and this:</p>
<pre><code class="language-c#">var segments = GetContext().Segments
        .Include(i =&gt; i.ChildSegments)
        .Include(i =&gt; i.ChildSegments)
        .Where(i =&gt; (i.ParentSegmentId == null) &amp;&amp; i.IsActive.HasValue &amp;&amp; i.IsActive.Value)
        .OrderBy(i =&gt; i.SegmentName);
</code></pre>
<p>I did not bother run SQL Profiler and dissect the SQL but in both cases there were no “grandchild” segments. (By the way, it’s been a few years so I should help to mention that EF6 over SQL Server still does not support the Nullable extension method <code>GetValueOrDefault()</code>. So, for the example above, we see <code>i.IsActive.HasValue &amp;&amp; i.IsActive.Value</code> in place of <code>i.IsActive.GetValueOrDefault()</code>.)</p>
<p>So my need for these “grandchild” segments suggests (correctly) that my <code>Segment</code> type has a “parent” <code>Segment</code>. This “self-join” can cause JSON.NET to throw a circular-reference exception and/or an out-of-memory exception (as it travels from parent to children—and children of children). Moreover, the <code>Segment</code> has a Documents collection (where each <code>Document</code> has a <code>Segment</code>—faithfully duplicated by JSON.NET until it runs out of memory!) To address these issues I have this:</p>
<pre><code class="language-c#">var documentSettings = new JsonSerializerSettings
{
    ContractResolver = new InterfaceContractResolver&lt;IDocument&gt;(),
    PreserveReferencesHandling = PreserveReferencesHandling.None,
    ReferenceLoopHandling = ReferenceLoopHandling.Ignore
};
</code></pre>
<p>What stands out is my <code>InterfaceContractResolver&lt;IDocument&gt;</code>, taking the guidance from Newton-King’s “<a href="http://www.newtonsoft.com/json/help/html/ContractResolver.htm">Serialization using ContractResolver</a>.” I’ve defined this resolver to ‘filter’ my Entity model Document through <code>IDocument</code> (which defines no parent-child relations):</p>
<pre><code class="language-c#">public class InterfaceContractResolver&lt;TInterface&gt; : DefaultContractResolver where TInterface : class
{
    protected override IList&lt;JsonProperty&gt; CreateProperties(Type type, MemberSerialization memberSerialization)
    {
        IList&lt;JsonProperty&gt; properties = base.CreateProperties(typeof(TInterface), memberSerialization);
        return properties;
    }
}
</code></pre>
<p>This looks straight forward when you want to do something like this:</p>
<pre><code class="language-c#">var rootDocuments = segment.ChildSegments.Select(k =&gt;
    {
        var rootDocument = context.Documents
            .Where(l =&gt; l.SegmentId == k.SegmentId)
            .Where(l =&gt; l.IsActive.HasValue &amp;&amp; l.IsActive.Value)
            .Where(l =&gt; l.IsRoot.HasValue &amp;&amp; l.IsRoot.Value)
            .FirstOrDefault();

var documentJson = JsonConvert.SerializeObject(rootDocument, documentSettings);
        return documentJson;
    })
    .ToArray();
</code></pre>
<p>But what I have here is an array of JSON strings—why did I do that? Well, it turns out that I cannot (it could just be me) configure JSON.NET to handle <code>enumerationOfDocuments</code> in this:</p>
<pre><code class="language-c#">var json = JsonConvert.SerializeObject(new
{
    SegmentId = segment.SegmentId,
    SegmentName = segment.SegmentName,
    SortOrdinal = segment.SortOrdinal,
    CreateDate = segment.CreateDate,
    ParentSegmentId = segment.ParentSegmentId,
    ClientId = segment.ClientId,
    IsActive = segment.IsActive,
    ChildDocuments = enumerationOfDocuments,
});
</code></pre>
<p>Either it is not possible or I do not know how to extend <code>DefaultContractResolver</code> to deal with an object that has an <code>IEnumerable&lt;Document&gt;</code> property that should be ‘filtered’ into <code>IEnumerable&lt;IDocument&gt;</code>.</p>
<p>So I’m resorting to old-fashioned string manipulation tricks to get around this limitation of me—or of JSON.NET.</p>
<p>@<a href="https://twitter.com/BryanWilhite">BryanWilhite</a></p>


</section>
<section class="meta">
    <span class="entry-date"> <strong>incept date:</strong> EEEE, MMMM d, y </span>
</section>
        </main>
        <footer>
            <div class="col-sm-8">
                <p>
                    Last Reviewed:
                    2015-04-03T07:00:00.000Z
                </p>
                <p>
                    Another stone tribal move by <a class="welcome" href="http://songhaysystem.com/">Songhay System</a>
                </p>
            </div>
            <div class="col-sm-4">
                <a href="http://twitter.com/BryanWilhite" target="_blank" title="@BryanWilhite">
                    <span class="zocial twitter icon"></span>
                </a>
                <a href="http://songhayblog.azurewebsites.net/entry/feed.xml" target="_blank" title="Atom feed">
                    <span class="zocial rss icon"></span>
                </a>
            </div>
        </footer>
    </body>

</html>